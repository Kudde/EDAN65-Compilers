package lang.ast;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "parser.beaver".
 */
public class LangParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short NEQUAL = 1;
		static public final short EQUAL = 2;
		static public final short SEMMIC = 3;
		static public final short LESS = 4;
		static public final short GREATER = 5;
		static public final short LEQUAL = 6;
		static public final short GEQUAL = 7;
		static public final short PLUS = 8;
		static public final short SUB = 9;
		static public final short RP = 10;
		static public final short COMMA = 11;
		static public final short LP = 12;
		static public final short ID = 13;
		static public final short NUMERAL = 14;
		static public final short BOOLEAN = 15;
		static public final short INT = 16;
		static public final short MUL = 17;
		static public final short DIV = 18;
		static public final short MOD = 19;
		static public final short IF = 20;
		static public final short WHILE = 21;
		static public final short RCARET = 22;
		static public final short RETURN = 23;
		static public final short LCARET = 24;
		static public final short ASSIGN = 25;
		static public final short ELSE = 26;

		static public final String[] NAMES = {
			"EOF",
			"NEQUAL",
			"EQUAL",
			"SEMMIC",
			"LESS",
			"GREATER",
			"LEQUAL",
			"GEQUAL",
			"PLUS",
			"SUB",
			"RP",
			"COMMA",
			"LP",
			"ID",
			"NUMERAL",
			"BOOLEAN",
			"INT",
			"MUL",
			"DIV",
			"MOD",
			"IF",
			"WHILE",
			"RCARET",
			"RETURN",
			"LCARET",
			"ASSIGN",
			"ELSE"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pTM5bi5LKO$kRExM9jeTXQIw4jSkzjRrdQWbQKJHGLKHP1hMXTG19VV32Hn4IDfW#AJoO" +
		"cweF69#E3mHUDyKaVZ54IABWXk86x0iMbOaL5xF4xovqvCtDwUvkcINN#VFdFzv$l$3DdcN" +
		"FFN23zZlWxQUZ59elDm2pK1kmIpAS$dJIfirWPRiQoWFLY2$rlSLDjGjQ7Mt5fm0V58AuIN" +
		"yHDFSzCjEC2N8XU8SG$k0ANOJdEmjKETI$h0xLgUurIdqtrdt53ETPRJAgl2$WVSSC6L5fC" +
		"gcyC#AcueG8hB7v67ASLsEy9EyFS8JiXJc1Lm8RZXikf3la8hhJuoOIDO4t8i0dhnFw0$vg" +
		"mdyIF8PDh0tS4V2Xku1Lb5lybRgesmYp#SznKROHP$A#ugTe8i$W#bo5VM2c6Pz28B79e8q" +
		"kiBBMw2lefMOlDwD7FZsvSZ8MOZciv26dSZflWemRJS1jvbJZYClP#hcbz7ix78l6PowXQR" +
		"CP8HmwxZ7SfF9FEzQdBGfM977IPfTAHZrncgNJaWCiGN2RoeSiibOx8CKPan3kiEVd0PLOE" +
		"7KdaYCphvouBSvXH$CHbrfrqv3sNMIeTUTTbbaf7FdQPfTAHzrrcgNJaaCiibURkDIolQe9" +
		"hs3MIrknFi3PHLsfjSjrch9xK1skvS5q$HhvlRSEvQ5MbRsnJKLdwsZOLbQMlR5DHMVhIDX" +
		"MLFXCRzQNY1sceGpCwSP6Q7yc1UGbja$XUMaGhULotG7mdBQAJFAvRcOYiJaJM9Y8R4v4RO" +
		"f5pOdnsXBT4M5U4BR5OWrMU8mQukyfpm3RLcm5fI8cZuYZPNbK3xhvwVGzWgpWcZfdvluNm" +
		"aEA#dERPgPodXKgUQ6gvmglLJZsTPLrVprbgu0vGnJDCaxELZ8IjsgYi2bhLigPfp3OoTrN" +
		"iJcEraLVOnjMNsb7xabGl82zTFPE$rAMhSzJQpotxL#ov6sCZaokYheweGMrZqTmvIrt3kQ" +
		"efecwCvDRwKTKy6OjGBTJrNr2h4GxdPmRVqpg#DxEvIxIWbJCzMWkjdvgruVFFuI$tNEuPM" +
		"Ov1bfRd$ZuFytc24Dm5tLd2rdeq9g2oPcAAgGhNU5KiZsjE9Yl7$rxbNCEgFa$8DUmOIMls" +
		"9rXRP4yPPssi9wftLcyTEymO#UHwcQneSjGZElLa#YthBbKx0TraHOhpKfbTzhctobwr1xs" +
		"fvXbGZzGYizgomOntX2kUPptWpdvvGXFYDDrMOXlB8$HvuZ7Y3MAZERdTHSXptKF4KyHBXF" +
		"pbVuj7ioVvkLr7$ppWyslJUn18UGJpfEePaxcpZBz2NGVzcupnt9zQHhGJ6uYbn7g2sjGEO" +
		"YTr3z0$Gxp8zjFeNsTxbjChMCTlE$yuOti9daDJHuWXndoYWVNCxmyJWk0zqw$HBsUUNVJt" +
		"qAya68Fy7kUtdVym$HPY7z53o6zhcUzn#lkOhuAU#V0eoosCFySowpngqo#GSppyjnbZsLj" +
		"7Vuf#Ets6aF$Bo7jpdBrA#jNqyhlkLM8FCTYlXZZz2EC7TPah5EWZdj3SEw2ztoEz2spVPp" +
		"JF6jvlskumlDpuxSRVRVnEepivUcv$oBfFarM#DoodoXpFT7#Hv#qqVNtPYYqniTt67pBnL" +
		"Q46XotzMaVUpOxOqr7kcRmOZiRLrQFUdOKAVBUuO#JeStpRvDcba#KylOOibnbK43v$8oJA" +
		"#4kHvla#fSxuNTHsqNUGTxFSpN8cWCUzm8$1uriFmZVmrDiUmkCku1DU1CsCDVE#BIot4d9" +
		"tc4Mq4Ol$1L3$HAe=");

	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}

	public LangParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // program = fun_list.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					 return new Program(a);
			}
			case 1: // fun_list = fun.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Fun a = (Fun) _symbol_a.value;
					 return new List().add(a);
			}
			case 2: // fun_list = fun_list.a fun.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Fun b = (Fun) _symbol_b.value;
					 return a.add(b);
			}
			case 3: // fun = type_decl.a id_decl.b param.c block.d
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final TypeDecl a = (TypeDecl) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final IdDecl b = (IdDecl) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 3];
					final Param c = (Param) _symbol_c.value;
					final Symbol _symbol_d = _symbols[offset + 4];
					final Block d = (Block) _symbol_d.value;
					 return new Fun(a, b, c, d);
			}
			case 4: // block = LCARET RCARET
			{
					 return new Block();
			}
			case 5: // block = LCARET stmt_list.a RCARET
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final List a = (List) _symbol_a.value;
					 return new Block(a);
			}
			case 6: // stmt_list = stmt.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Stmt a = (Stmt) _symbol_a.value;
					 return new List().add(a);
			}
			case 7: // stmt_list = stmt_list.a stmt.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Stmt b = (Stmt) _symbol_b.value;
					 return a.add(b);
			}
			case 10: // stmt = expr.a SEMMIC
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new ExprStmt(a);
			}
			case 11: // stmt = WHILE LP expr.a RP block.b
			{
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					 return new WhileStmt(a, b);
			}
			case 12: // stmt = IF LP expr.a RP block.b
			{
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					 return new IfStmt(a, b, new Opt());
			}
			case 13: // stmt = IF LP expr.a RP block.b ELSE block.c
			{
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 7];
					final Block c = (Block) _symbol_c.value;
					 return new IfStmt(a, b, new Opt(c));
			}
			case 14: // stmt = RETURN expr.a SEMMIC
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new ReturnStmt(a);
			}
			case 15: // decl = type_decl.a id_decl.b SEMMIC
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final TypeDecl a = (TypeDecl) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final IdDecl b = (IdDecl) _symbol_b.value;
					 return new DeclStmt(a, b, new Opt());
			}
			case 16: // decl = type_decl.a id_decl.b ASSIGN expr.c SEMMIC
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final TypeDecl a = (TypeDecl) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final IdDecl b = (IdDecl) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 4];
					final Expr c = (Expr) _symbol_c.value;
					 return new DeclStmt(a, b, new Opt(c));
			}
			case 17: // assign = id_use.a ASSIGN expr.b SEMMIC
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdUse a = (IdUse) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new AssignStmt(a, b);
			}
			case 18: // param = LP RP
			{
					 return new Param();
			}
			case 19: // param = LP param_list.a RP
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final List a = (List) _symbol_a.value;
					 return new Param(a);
			}
			case 20: // param_list = param_decl.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final ParamDecl a = (ParamDecl) _symbol_a.value;
					 return new List().add(a);
			}
			case 21: // param_list = param_list.a COMMA param_decl.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final ParamDecl b = (ParamDecl) _symbol_b.value;
					 return a.add(b);
			}
			case 22: // param_decl = type_decl.a id_decl.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final TypeDecl a = (TypeDecl) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final IdDecl b = (IdDecl) _symbol_b.value;
					 return new ParamDecl(a, b);
			}
			case 23: // expr_list = expr.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new List().add(a);
			}
			case 24: // expr_list = expr_list.a COMMA expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return a.add(b);
			}
			case 25: // expr = expr.a NEQUAL comp_expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new NotEqual(a, b);
			}
			case 26: // expr = expr.a EQUAL comp_expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Equal(a, b);
			}
			case 27: // expr = comp_expr.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 28: // comp_expr = comp_expr.a LESS bin_expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Less(a, b);
			}
			case 29: // comp_expr = comp_expr.a GREATER bin_expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Greater(a, b);
			}
			case 30: // comp_expr = comp_expr.a LEQUAL bin_expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new LessEqual(a, b);
			}
			case 31: // comp_expr = comp_expr.a GEQUAL bin_expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new GreaterEqual(a, b);
			}
			case 32: // comp_expr = bin_expr.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 34: // bin_expr = bin_expr.a PLUS term.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Plus(a, b);
			}
			case 35: // bin_expr = bin_expr.a SUB term.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Sub(a, b);
			}
			case 36: // bin_expr = term.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 37: // term = term.a MUL factor.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mul(a, b);
			}
			case 38: // term = term.a DIV factor.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Div(a, b);
			}
			case 39: // term = term.a MOD factor.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mod(a, b);
			}
			case 40: // term = factor.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Expr b = (Expr) _symbol_b.value;
					 return b;
			}
			case 41: // factor = LP expr.a RP
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 46: // fun_call = ID.id LP RP
			{
					final Symbol id = _symbols[offset + 1];
					 return new FunCall(new IdUse(id), new List());
			}
			case 47: // fun_call = ID.id LP expr_list.a RP
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 3];
					final List a = (List) _symbol_a.value;
					 return new FunCall(new IdUse(id), a);
			}
			case 48: // literal = NUMERAL.i
			{
					final Symbol i = _symbols[offset + 1];
					 return new Literal(i);
			}
			case 49: // bool_literal = BOOLEAN.i
			{
					final Symbol i = _symbols[offset + 1];
					 return new BoolLiteral(i);
			}
			case 50: // type_decl = INT.i
			{
					final Symbol i = _symbols[offset + 1];
					 return new TypeDecl(i);
			}
			case 51: // id_use = ID.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new IdUse(id);
			}
			case 52: // id_decl = ID.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new IdDecl(id);
			}
			case 33: // bin_expr = 
			{
				return new Symbol(null);
			}
			case 8: // stmt = decl
			case 9: // stmt = assign
			case 42: // factor = id_use
			case 43: // factor = fun_call
			case 44: // factor = literal
			case 45: // factor = bool_literal
			{
				return _symbols[offset + 1];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
