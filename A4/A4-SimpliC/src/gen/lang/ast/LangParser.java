package lang.ast;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "parser.beaver".
 */
public class LangParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short NEQUAL = 1;
		static public final short EQUAL = 2;
		static public final short SEMMIC = 3;
		static public final short LESS = 4;
		static public final short GREATER = 5;
		static public final short LEQUAL = 6;
		static public final short GEQUAL = 7;
		static public final short PLUS = 8;
		static public final short SUB = 9;
		static public final short RP = 10;
		static public final short LP = 11;
		static public final short ID = 12;
		static public final short COMMA = 13;
		static public final short NUMERAL = 14;
		static public final short INT = 15;
		static public final short IF = 16;
		static public final short WHILE = 17;
		static public final short RCARET = 18;
		static public final short RETURN = 19;
		static public final short MUL = 20;
		static public final short DIV = 21;
		static public final short MOD = 22;
		static public final short LCARET = 23;
		static public final short ASSIGN = 24;
		static public final short ELSE = 25;

		static public final String[] NAMES = {
			"EOF",
			"NEQUAL",
			"EQUAL",
			"SEMMIC",
			"LESS",
			"GREATER",
			"LEQUAL",
			"GEQUAL",
			"PLUS",
			"SUB",
			"RP",
			"LP",
			"ID",
			"COMMA",
			"NUMERAL",
			"INT",
			"IF",
			"WHILE",
			"RCARET",
			"RETURN",
			"MUL",
			"DIV",
			"MOD",
			"LCARET",
			"ASSIGN",
			"ELSE"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9p5brji5bKGnsTtlrheXGeMMg7S#fLoAr2eW7T4H5HGGUe5KT4depwG61DzCV4INpG#QQA" +
		"F9lfYV3AQg8cH5r#yLEvtiEMEADuGKRIilpDx#dLtptxzlhO4Tp8pvypyvypisNFETpwHt8" +
		"Rm7vSafp98sFBI8IqoJSRHE##ITAgyEs7hYvb2xqoQf4BbVGbRNXeruZAv9Vm#JJ92hfHMg" +
		"PG5qYbBv5ePARTceAvJr8W2gXhKNscI6rNUbB2UIvECKBaiOVqpJQ2CN9wmdaqJSsFa7Gdh" +
		"7mvjLdawOVlTeP#CPCxZjj$IH4OZ7qvOVqsJIByiq2zfmb#G1VevJVWBia1$fqbMgfI4zJk" +
		"NPBgiGlQjedbIR#s2TBuxNvxlZbmmeE#WIyA3xCypIHfaghI7#rnIxBuOTgxr3BMU0ovfZW" +
		"En70jjFNjTKknUiCq66uPXh$NiT8drqelCotp5$XjUi9uT6MIyEsIqJ93BLTvcxTjTqXgsw" +
		"wvRpAuJcMKzsroI#y5kKsodOiLw1fgZ$Ivfv7uTPvsEyw2TepqkoKDWzoXslSqPURQufDuj" +
		"clcKmOQdh6UtIuhThRDpbygrrZFGkspDe1$27oCfzh7sNIwfTvV47cjVNLWjYwHDwkHswxu" +
		"NhfLHMaDLeg8PyVN9EDdrkgj8t5pMKoDh2haonYEoQAvoV2cF3Djt94uoLYOZpOmU2G$7IJ" +
		"s7rNCuF1GdzHnIpw6m9qxgwL5FJzWT9$LqgwSxF6v8hf29CaUkKjlnI8R732KynwpC9sR$Q" +
		"cn73IMmHn4paKdi#5H$Tgf$VQg$DDLVaUhVcUhVa#YFIVIQmYvgoka#sK25NQOF#tADiONV" +
		"uZK#q#uAJwW#4Px4UWEI7Imtwtf#9BRq7u0zHWWOju8xGoM$#YCv2QjPYTDa52lJd5rZc9d" +
		"nZDp4$4pYssV5r6bCJT4ODw958wep8sPbHZHeH3uHuQAg5TLG0fNFo3xKZEMXQXJLKXQgLF" +
		"LHnhgBaJ4C3GfvoL3qoa5LWMhaDEnVHPEbdhq$ZiZ68lWQSteEriTlVfYLPxZO$w4UynIlf" +
		"muQ73RoHB9K3UQDglZjCktYurOLi7K6Isz8ypUedCq5xFHIEGSphiMMDKS3hWL3jOP2#vJA" +
		"6SOUYuslbYdSuvgjjnMU8JDrhBRYDO4girwGJYvRGolxqkRA6azt$31yHS#QY#PBVTDBx55" +
		"RQKzgzh5bOcMkYxt4$MGleAPchNMQgL2gzMrcqpAsUVOz33TQMws#XzaRpONtdnvR#NCumH" +
		"vz8Rh9ZELISW8szvq9y49u2VrUz2fxs#7MH4qYJyElm6#B#AFG7u1RBn9yWNu2$JnsSDwpw" +
		"7RqwzXcSlLQJFjTsj#WFqI$Yh#JzYRqasXkzXx$G7mFRg2z37q6fawVypR0dbkAvhxhumlU" +
		"Gg#1UGN$STZaVGD#7zzxC3dyJuXPZkwARcu1DUHMs7ybr2lFOCEVMqdxERW3VWtUYdqjSQD" +
		"fcxiiOth4oZdiZs5$XtuLSVn32#hWZTXuDy$yBdoEvhtzkRG$HlEFKxw4DzD#6SrDtlyK$W" +
		"pSXMZ#SsFv82Vjjp0tnAdmegZlVntfG8pEOk9h8#qjDfgnpjknvjZOdHPNRt5FMNzV$wliS" +
		"ODDiVR1$hRtOgpTdOpnFYfUPt3CvbqNivssjerMlsJjP$inycOCt#kEcwl8iCrFzltLTgok" +
		"f5sV3luZUEmcm#mmJeCyEi#ajs5hezsAZjYqAonNmW6djk4ApkuSTsyV3jXT7Xpmc#bpbdX" +
		"mm5VjOy$iw1Hxx7E10yiUEp#8iSVE362lm4tqcyWvaROv6yR3BN3xVy2SlDi=");

	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}

	public LangParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // program = fun_list.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					 return new Program(a);
			}
			case 1: // fun_list = fun.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Fun a = (Fun) _symbol_a.value;
					 return new List().add(a);
			}
			case 2: // fun_list = fun_list.a fun.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Fun b = (Fun) _symbol_b.value;
					 return a.add(b);
			}
			case 3: // fun = type_decl.a id_decl.b param.c block.d
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Type a = (Type) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final IdDecl b = (IdDecl) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 3];
					final Param c = (Param) _symbol_c.value;
					final Symbol _symbol_d = _symbols[offset + 4];
					final Block d = (Block) _symbol_d.value;
					 return new Fun(a, b, c, d);
			}
			case 4: // block = LCARET RCARET
			{
					 return new Block();
			}
			case 5: // block = LCARET stmt_list.a RCARET
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final List a = (List) _symbol_a.value;
					 return new Block(a);
			}
			case 6: // stmt_list = stmt.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Stmt a = (Stmt) _symbol_a.value;
					 return new List().add(a);
			}
			case 7: // stmt_list = stmt_list.a stmt.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Stmt b = (Stmt) _symbol_b.value;
					 return a.add(b);
			}
			case 10: // stmt = expr.a SEMMIC
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new ExprStmt(a);
			}
			case 11: // stmt = WHILE LP expr.a RP block.b
			{
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					 return new WhileStmt(a, b);
			}
			case 12: // stmt = IF LP expr.a RP block.b
			{
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					 return new IfStmt(a, b, new Opt());
			}
			case 13: // stmt = IF LP expr.a RP block.b ELSE block.c
			{
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 7];
					final Block c = (Block) _symbol_c.value;
					 return new IfStmt(a, b, new Opt(c));
			}
			case 14: // stmt = RETURN expr.a SEMMIC
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new ReturnStmt(a);
			}
			case 15: // decl = type_decl.a id_decl.b SEMMIC
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Type a = (Type) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final IdDecl b = (IdDecl) _symbol_b.value;
					 return new DeclStmt(a, b, new Opt());
			}
			case 16: // decl = type_decl.a id_decl.b ASSIGN expr.c SEMMIC
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Type a = (Type) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final IdDecl b = (IdDecl) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 4];
					final Expr c = (Expr) _symbol_c.value;
					 return new DeclStmt(a, b, new Opt(c));
			}
			case 17: // assign = id_use.a ASSIGN expr.b SEMMIC
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdUse a = (IdUse) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new AssignStmt(a, b);
			}
			case 18: // param = LP RP
			{
					 return new Param();
			}
			case 19: // param = LP param_list.a RP
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final List a = (List) _symbol_a.value;
					 return new Param(a);
			}
			case 20: // param_list = param_decl.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final ParamDecl a = (ParamDecl) _symbol_a.value;
					 return new List().add(a);
			}
			case 21: // param_list = param_list.a COMMA param_decl.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final ParamDecl b = (ParamDecl) _symbol_b.value;
					 return a.add(b);
			}
			case 22: // param_decl = type_decl.a id_decl.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Type a = (Type) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final IdDecl b = (IdDecl) _symbol_b.value;
					 return new ParamDecl(a, b);
			}
			case 23: // expr_list = expr.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new List().add(a);
			}
			case 24: // expr_list = expr_list.a COMMA expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return a.add(b);
			}
			case 25: // expr = expr.a NEQUAL comp_expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new NotEqual(a, b);
			}
			case 26: // expr = expr.a EQUAL comp_expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Equal(a, b);
			}
			case 27: // expr = comp_expr.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 28: // comp_expr = comp_expr.a LESS bin_expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Less(a, b);
			}
			case 29: // comp_expr = comp_expr.a GREATER bin_expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Greater(a, b);
			}
			case 30: // comp_expr = comp_expr.a LEQUAL bin_expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new LessEqual(a, b);
			}
			case 31: // comp_expr = comp_expr.a GEQUAL bin_expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new GreaterEqual(a, b);
			}
			case 32: // comp_expr = bin_expr.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 34: // bin_expr = bin_expr.a PLUS term.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Plus(a, b);
			}
			case 35: // bin_expr = bin_expr.a SUB term.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Sub(a, b);
			}
			case 36: // bin_expr = term.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 37: // term = term.a MUL factor.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mul(a, b);
			}
			case 38: // term = term.a DIV factor.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Div(a, b);
			}
			case 39: // term = term.a MOD factor.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mod(a, b);
			}
			case 40: // term = factor.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Expr b = (Expr) _symbol_b.value;
					 return b;
			}
			case 41: // factor = LP expr.a RP
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 45: // fun_call = ID.id LP RP
			{
					final Symbol id = _symbols[offset + 1];
					 return new FunCall(new IdUse(id), new List());
			}
			case 46: // fun_call = ID.id LP expr_list.a RP
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 3];
					final List a = (List) _symbol_a.value;
					 return new FunCall(new IdUse(id), a);
			}
			case 47: // literal = NUMERAL.i
			{
					final Symbol i = _symbols[offset + 1];
					 return new Literal(i);
			}
			case 48: // type_decl = INT.i
			{
					final Symbol i = _symbols[offset + 1];
					 return new IntType(i);
			}
			case 49: // id_use = ID.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new IdUse(id);
			}
			case 50: // id_decl = ID.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new IdDecl(id);
			}
			case 33: // bin_expr = 
			{
				return new Symbol(null);
			}
			case 8: // stmt = decl
			case 9: // stmt = assign
			case 42: // factor = id_use
			case 43: // factor = fun_call
			case 44: // factor = literal
			{
				return _symbols[offset + 1];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
